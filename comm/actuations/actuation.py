"""
Created on Sep. 23, 2021
@author: Heng-Sheng (Hanson) Chang
"""

import numpy as np
from numba import njit

from elastica._linalg import _batch_cross
from elastica._calculus import quadrature_kernel, difference_kernel
from elastica.external_forces import inplace_addition

from elastica.external_forces import NoForces

from comm._rod_tool import _lab_to_material, _material_to_lab, average2D

@njit(cache=True)
def _internal_to_external_load(
    director_collection, kappa, tangents,
    rest_lengths, rest_voronoi_lengths,
    dilatation, voronoi_dilatation,
    internal_force, internal_couple,
    external_force, external_couple
    ):

    external_force[:, :] = difference_kernel(
        _material_to_lab(director_collection, internal_force)
        )

    external_couple[:, :] = (
        difference_kernel(internal_couple) +
        quadrature_kernel(
            _batch_cross(kappa, internal_couple) * rest_voronoi_lengths
        ) +
        _batch_cross(
                _lab_to_material(director_collection, tangents * dilatation),
                internal_force
            )  * rest_lengths
    )

@njit(cache=True)
def _force_induced_couple(internal_forces, distance, internal_couples):
    internal_couples[:, :] = average2D(
        _batch_cross(distance, internal_forces)
    )

class ContinuousActuation:
    """
    Classes inherited from this base class should contain parameters and
    functions that describe and calculate forces / couples generated by
    actuators.
    """

    def __init__(self, n_elements: int):
        self.internal_force = np.zeros((3, n_elements))       # material frame
        self.external_force = np.zeros((3, n_elements+1))     # lab frame
        self.internal_couple = np.zeros((3, n_elements-1))    # material frame
        self.external_couple = np.zeros((3, n_elements))      # material frame

    def __call__(self, system, time):
        raise NotImplementedError
    
    def reset_actuation(self,):
        self.internal_force[:, :] *= 0
        self.external_force[:, :] *= 0
        self.internal_couple[:, :] *= 0
        self.external_couple[:, :] *= 0

class ApplyActuations(NoForces):
    def __init__(self, actuations, step_skip: int, callback_params_list: list):
        self.current_step = 0
        self.actuations = actuations
        self.every = step_skip
        self.callback_params_list = callback_params_list

    def apply_torques(self, system, time: np.float = 0.0):
        for actuation in self.actuations:
            actuation(system)
            inplace_addition(
                system.external_forces, actuation.external_force
            )
            inplace_addition(
                system.external_torques, actuation.external_couple
            )

        self.make_callback()

    def make_callback(self,):
        if self.current_step % self.every == 0:
            self.callback_func(
                self.actuations,
                self.callback_params_list
            )
        self.current_step += 1

    def callback_func(self, actuations, callback_params_list):
        for actuation, callback_params in zip(
            actuations, callback_params_list
        ):
            callback_params['internal_force'].append(
                actuation.internal_force.copy()
            )
            callback_params['internal_couple'].append(
                actuation.internal_couple.copy()
            )
            callback_params['external_force'].append(
                actuation.external_forces.copy()
            )
            callback_params['external_couple'].append(
                actuation.external_couple.copy()
            )
